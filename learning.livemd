# ML training 101

```elixir
Mix.install([
  {:nx, "~> 0.10.0"},
  {:tucan, "~> 0.5.0"},
  {:kino_vega_lite, "~> 0.1.9"},
  {:kino, "~> 0.10.0"},
  {:kino_explorer, "~> 0.1.7"},
  {:explorer, "~> 0.11.1"},
  {:scholar, "~> 0.2.1"}
])
```

## Definitions and setup

First, we import and require and alias some utilities

```elixir
require Explorer.DataFrame, as: DF
require Explorer.Series, as: S
alias Scholar.Linear.LinearRegression, as: LR
alias Scholar.Linear.PolynomialRegression, as: PR
alias Scholar.Impute.SimpleImputer
alias Scholar.Metrics.Regression
```

Then, let's define a module that "represents the truth".

This is obviously not possible in a real-world scenario.
The following is here for educational purposes.

```elixir
defmodule Data do
  import Nx.Defn

  @n 50

  @a -0.000_005
  @b -0.150
  @c 125_000

  @miles_min 10_000
  @miles_max 120_000
  @noise_mean 10_000
  @noise_deviation 3_000

  defn data do
    key = Nx.Random.key(42069)
    {x, new_key} = Nx.Random.uniform(key, @miles_min, @miles_max, shape: {@n, 1}, type: :f64)
    {noise, _} = Nx.Random.normal(new_key, @noise_mean, @noise_deviation, shape: {@n, 1})
    y = @a * x ** 2 + @b * x + @c + noise
    {x, y}
  end
end

{mileage, prices} = Data.data()

Tucan.scatter([mileage: mileage, prices: prices], "mileage", "prices",
  width: 800,
  height: 760,
  filled: true
)
|> Tucan.Grid.set_enabled(false)
|> Tucan.set_title("How prices change wrt mileage", offset: 20)
```

TODO

```elixir
%LR{intercept: intercept, coefficients: coefficients} = model = LR.fit(mileage, prices)
[m] = Nx.to_flat_list(coefficients)
[q] = Nx.to_flat_list(intercept)
{m,q}
```

```elixir
x1 = 0
y1 = x1 * m + q
x2 = 135_000
y2 = x2 * m + q
{{x1, y1}, {x2, y2}}
```

```elixir
Tucan.layers([
  Tucan.scatter([mileage: mileage, prices: prices], "mileage", "prices",
    width: 800,
    height: 760,
    filled: true
  ),
  Tucan.lineplot([x: [x1, x2], y: [y1, y2]], "x", "y")
])
```

```elixir
input = Kino.Input.text("dammi il chilometraggio")
```

```elixir
i = Kino.Input.read(input)
{kms, _} = Integer.parse(i)

result = LR.predict(model, Nx.tensor([[kms]]))
[predicted] = Nx.to_flat_list(result)

IO.puts(predicted)

Tucan.layers([
  Tucan.scatter([mileage: mileage, prices: prices], "mileage", "prices",
    width: 800,
    height: 500,
    filled: true
  ),
  Tucan.lineplot([x: [x1, x2], y: [y1, y2]], "x", "y"),
  Tucan.scatter([x: [kms], y: [predicted]], "x", "y", point_color: "red", point_size: 100)
])
```

```elixir
%PR{coefficients: pr_coeff, intercept: pr_intercept} =
  pr_model = PR.fit(mileage, prices, degree: 2)

x_p = 0..130_000

x_vector =
  x_p
  |> Enum.map(&Function.identity/1)
  |> Nx.tensor()
  |> Nx.reshape({:auto, 1})

y_p = PR.predict(pr_model, x_vector)

Tucan.layers([
  Tucan.scatter([mileage: mileage, prices: prices], "mileage", "prices",
    width: 800,
    height: 500,
    filled: true
  ),
  Tucan.lineplot([x: [x1, x2], y: [y1, y2]], "x", "y"),
  Tucan.lineplot([y: y_p, x: x_vector], "x", "y", line_color: "green")
])
```
