================================================================================
JUSTIFICATION QUIZ ENGINE - IMPLEMENTATION PLAN
================================================================================

Project: Self-Assessment Quiz Application
Framework: Elixir + Phoenix LiveView
Generated: November 10, 2025

================================================================================
PROJECT OVERVIEW
================================================================================

Build a single-session, privacy-focused quiz application where users:
- Answer 10 randomly selected questions
- Provide both option selection AND textual justification
- Receive only the correct answers and explanations (NO scoring)
- Leave NO trace after session ends (stateless, no persistence)

================================================================================
PHASE 1: PROJECT SETUP & FOUNDATION
================================================================================

1.1 Initialize Phoenix Project
   - Run: mix phx.new ai_quizzer --no-mailer
   - --no-mailer since no email functionality needed
   - Database will (currently) store ONLY questions, NOT user responses

1.2 Configure Dependencies
   - Ensure :req is available (Phoenix 1.8 includes it by default)
   - Verify Tailwind CSS v4 setup in assets/css/app.css
   - Ecto and PostgreSQL (or SQLite for simplicity) included by default
   - No additional dependencies needed for core functionality

1.3 Database Configuration
   - Configure database in config/dev.exs and config/test.exs
   - Consider SQLite for simplicity (single file, no external DB needed)
   - Or PostgreSQL for production-like setup
   - Database is READ-ONLY for questions, NO user data tables

1.4 Set Up Mix Precommit Alias
   - Add to mix.exs:
     defp aliases do
       [
         precommit: ["format", "compile --warnings-as-errors", "credo"]
       ]
     end
   - May need to add credo dependency

================================================================================
PHASE 2: DATA LAYER (QUESTION BANK WITH ECTO)
================================================================================

2.1 Create Question Schema
   - Module: lib/ai_quizzer/quiz/question.ex
   - Use Ecto.Schema for database mapping
   - Fields:
     * id: :id (primary key, auto-increment)
     * question: :string (the question text)
     * option_1: :string (first option)
     * option_2: :string (second option)
     * option_3: :string (third option)
     * option_4: :string (fourth option)
     * correct_answer: :string (must match one of the options)
     * motivation: :string (explanation for correct answer)
     * inserted_at: :naive_datetime
     * updated_at: :naive_datetime
   - Virtual field: options (derived from option_1..option_4 for convenience)

2.2 Create Migration
   - File: priv/repo/migrations/TIMESTAMP_create_questions.exs
   - Create questions table with all fields
   - Add index on id for fast random selection
   - Ensure NOT NULL constraints on required fields

2.3 Create Context Module
   - Module: lib/ai_quizzer/quiz.ex
   - Public API functions:
     * list_questions/0 - Get all questions
     * get_question!/1 - Get single question by ID
     * random_questions/1 - Get N random questions (default 10)
     * count_questions/0 - Count total questions in database
   - Use Ecto.Query for efficient random selection:
     from(q in Question, order_by: fragment("RANDOM()"), limit: ^count)

2.4 Seed Data Integration
   - File: priv/repo/seeds.exs
   - Read seeding.json file
   - Parse JSON into question structs
   - Use Repo.insert!/1 or Repo.insert_all/2 to populate database
   - Handle existing data (truncate first or check for duplicates)
   - Validation: ensure each question has exactly 4 options
   - Transform JSON structure to match schema (array of options -> option_1..4)

================================================================================
PHASE 3: CORE LIVEVIEW - QUIZ SESSION
================================================================================

3.1 Create Main Quiz LiveView
   - Module: lib/ai_quizzer_web/live/quiz_live.ex
   - Route: "/" (root path)
   - Responsibilities:
     * Initialize quiz session with 10 random questions
     * Track user inputs (option selections + justifications)
     * Validate completion status
     * Handle submission
     * Display results

3.2 LiveView State Management
   - Socket assigns:
     * questions: list of 10 Question structs (from Ecto)
     * user_answers: map of %{question_index => %{option: selected, justification: text}}
     * view_mode: :quiz | :results
     * submission_enabled: boolean

3.3 Mount Function
   def mount(_params, _session, socket) do
     # Fetch 10 random questions from database
     questions = Quiz.random_questions(10)
     
     socket =
       socket
       |> assign(:questions, questions)
       |> assign(:user_answers, %{})
       |> assign(:view_mode, :quiz)
       |> assign(:submission_enabled, false)
     
     {:ok, socket}
   end

3.4 Event Handlers
   - handle_event("select_option", %{"index" => i, "option" => opt}, socket)
     * Update user_answers map
     * Recalculate submission_enabled
   
   - handle_event("update_justification", %{"index" => i, "text" => text}, socket)
     * Update user_answers map
     * Recalculate submission_enabled
   
   - handle_event("submit_quiz", _params, socket)
     * Change view_mode to :results
     * Keep questions and user_answers for comparison (optional)

3.5 Validation Logic
   - Helper function: all_questions_answered?/1
   - Check for each question (0-9):
     * Has selected option
     * Has non-empty justification text (trim whitespace)
   - Update submission_enabled assign accordingly

================================================================================
PHASE 4: UI/UX DESIGN - QUIZ VIEW
================================================================================

4.1 Quiz Template Structure
   - File: lib/ai_quizzer_web/live/quiz_live.html.heex
   - Wrap in: <Layouts.app flash={@flash}>
   - Conditional rendering based on @view_mode

4.2 Quiz Mode UI Components
   - Header section:
     * App title (use DaisyUI .navbar or hero section)
     * Instructions (10 questions, justify each answer)
     * Privacy notice (no data stored) - use DaisyUI .alert .alert-info
   
   - Question cards (iterate through @questions):
     * Use DaisyUI .card .card-bordered for each question
     * Question number and text (.card-title)
     * Radio button group for 4 options
       - Use DaisyUI .form-control and .radio classes
       - Use phx-click="select_option" with question index
       - Highlight selected option
     * Text area for justification
       - Use DaisyUI .textarea .textarea-bordered
       - Use phx-change="update_justification" or phx-blur
       - Placeholder: "Explain why you chose this answer..."
       - Minimum height for comfortable typing
   
   - Submit button:
     * Use DaisyUI .btn .btn-primary
     * Disabled state: .btn-disabled when @submission_enabled == false
     * Clear visual feedback (grayed out when disabled)
     * Button text: "Submit Quiz"

4.3 Design Guidelines
   - **Prefer DaisyUI components first**, then Tailwind CSS for custom styling
   - DaisyUI is included by default in Phoenix 1.8+
   - Use DaisyUI components: card, btn, radio, textarea, badge, etc.
   - Leverage DaisyUI themes for consistent color schemes
   - Supplement with Tailwind utilities for spacing, layout, and custom tweaks
   - Implement subtle hover effects on interactive elements
   - Use card-based layout for questions (DaisyUI .card class)
   - Ensure proper spacing between questions
   - Mobile-responsive design (stack elements on small screens)
   - Color scheme: Use DaisyUI theme (consider 'corporate', 'cupcake', or custom)
   - Typography: Clear hierarchy (question > options > instructions)

4.4 Micro-interactions
   - Radio button: DaisyUI .radio component with smooth transitions
   - Text area: DaisyUI .textarea with focus states
   - Submit button: DaisyUI .btn with hover effects (.btn-primary when enabled)
   - Disabled button: DaisyUI .btn-disabled class
   - Use DaisyUI's built-in animation utilities where appropriate

================================================================================
PHASE 5: UI/UX DESIGN - RESULTS VIEW
================================================================================

5.1 Results Template Structure
   - Conditional block within quiz_live.html.heex
   - Display when @view_mode == :results

5.2 Results Display Components
   - Header:
     * "Quiz Complete" or "Review Your Answers" (DaisyUI .hero and/or .text-3xl)
     * NO score display (per requirements)
   
   - Results cards (for each question):
     * Use DaisyUI .card .card-bordered for each result
     * Question number and text (.card-title)
     * "Correct Answer:" label + the correct option
       - Use DaisyUI .badge .badge-success or .alert .alert-success
     * "Explanation:" label + the motivation text
       - Display in .card-body
     * Visual separation between questions
   
   - Action buttons:
     * "Take Another Quiz" - DaisyUI .btn .btn-primary
     * Optional: "Return to Start" link

5.3 Results Styling
   - Distinct visual style from quiz mode
   - Use DaisyUI .alert or .badge classes for correct answer highlighting
   - Correct answer highlighted with DaisyUI success color variant
   - Explanation text: easy to read, adequate font size
   - Card-based layout matching quiz view (DaisyUI .card)
   - Use DaisyUI .btn-success or similar for action buttons
   - Celebration/completion feel (without showing score)

================================================================================
PHASE 6: ROUTING & NAVIGATION
================================================================================

6.1 Router Configuration
   - File: lib/ai_quizzer_web/router.ex
   - Add live route in :browser scope:
     
     scope "/", ItsAaPn2025MachineLearningWeb do
       pipe_through :browser
       
       live "/", QuizLive, :index
     end

6.2 Navigation Flow
   - Single page application (SPA) feel
   - No need for multiple routes (single LiveView handles both modes)
   - "Take Another Quiz" button triggers remount or reset

================================================================================
PHASE 7: VALIDATION & ERROR HANDLING
================================================================================

7.1 Input Validation
   - Option selection: ensure value matches one of the 4 options
   - Justification text:
     * Trim whitespace
     * Minimum length check (e.g., 10 characters) - Optional but recommended
     * Maximum length (prevent abuse) - Optional

7.2 Data Validation
   - Question loading from database: ensure all fields present
   - Handle empty question bank gracefully
   - Database seeding validation:
     * Verify seeding.json structure before insert
     * Ensure 4 options per question
     * Validate correct_answer matches one of the options
     * Log warnings for invalid questions (skip during seeding)

7.3 Error States
   - Failed to load questions: show friendly error message
   - Empty question bank: prevent quiz start
   - Client-side validation feedback (if justification too short)

================================================================================
PHASE 8: TESTING STRATEGY
================================================================================

8.1 Unit Tests
   - Test Quiz context module:
     * random_questions/1 returns exactly 10 unique questions
     * random_questions/1 returns different sets on multiple calls
     * count_questions/0 returns correct count
     * Questions have all required fields
   
   - Test Question schema:
     * Virtual options field works correctly
     * Changeset validations (if any)

8.2 LiveView Tests
   - File: test/ai_quizzer_web/live/quiz_live_test.exs
   - Test scenarios:
     * Mount loads 10 questions
     * Submit button starts disabled
     * Selecting option updates state
     * Adding justification updates state
     * Submit button enables when all 10 complete
     * Clicking submit shows results view
     * Results display correct answers and motivations
     * "Take Another Quiz" resets properly

8.3 Test Implementation Approach
   - Use Phoenix.LiveViewTest functions
   - Reference element IDs from templates
   - Use has_element?/2 for assertions
   - Test user flow end-to-end
   - Use render_submit/2 for form testing

================================================================================
PHASE 9: PRIVACY & STATELESSNESS VERIFICATION
================================================================================

9.1 Verify No USER Data Persistence
   - Confirm no database tables for user responses
   - Questions table is READ-ONLY after seeding
   - No database writes during quiz session
   - No GenServers storing user data beyond session
   - No file writes of user responses/justifications
   - No logging of user answers/justifications

9.2 Session Lifecycle
   - User data exists only in LiveView socket assigns
   - Data cleared when user closes tab/browser
   - Each new session fetches fresh random questions from DB
   - No cookies storing quiz data

9.3 Privacy Documentation
   - Add privacy notice in UI
   - Document in README: "Questions stored in DB, user responses never saved"
   - Clarify: Database contains ONLY the question bank

================================================================================
PHASE 10: POLISH & FINALIZATION
================================================================================

10.1 UI Polish
   - Implement all micro-interactions
   - Ensure smooth transitions between states
   - Add loading states if needed (though should be instant)
   - Test on multiple screen sizes
   - Verify accessibility (keyboard navigation, ARIA labels)

10.2 Code Quality
   - Run mix precommit
   - Fix any compiler warnings
   - Ensure consistent code formatting
   - Add module documentation (@moduledoc)
   - Add function documentation (@doc)

10.3 Documentation
   - Update README with:
     * Project description
     * How to run locally (including database setup)
     * How to seed database: mix ecto.setup
     * How to add questions to seeding.json and re-seed
     * Privacy guarantees (questions in DB, user responses never stored)
     * Technology stack (Phoenix, LiveView, Ecto)

10.4 Performance Optimization
   - Ensure question queries are efficient (indexed primary key)
   - Consider database connection pooling (default with Ecto)
   - Random selection query optimization (RANDOM() vs alternatives)
   - Minimize re-renders in LiveView
   - Optimize CSS bundle size

================================================================================
ADDITIONAL BENEFITS OF USING ECTO
================================================================================

1. **Easier Question Management**: 
   - Can add/edit/remove questions via database tools
   - No need to parse JSON on every request
   - Can use migrations to evolve question schema

2. **Better Performance**:
   - Database handles random selection efficiently
   - No need to load all questions into memory
   - Connection pooling already configured

3. **Testing Benefits**:
   - Use test database with sandbox mode
   - Clean slate for each test
   - Easy to create test fixtures

4. **Future Extensibility**:
   - Easy to add categories, difficulty levels, tags later
   - Can add analytics on question usage (if desired)
   - Can implement question versioning

5. **Data Integrity**:
   - Database constraints ensure data validity
   - Transactions if needed
   - Consistent data across app restarts

================================================================================
IMPLEMENTATION ORDER (RECOMMENDED)
================================================================================

DAY 1: Foundation
1. Initialize Phoenix project with Ecto (Phase 1)
2. Create Question schema and migration (Phase 2.1-2.2)
3. Create Quiz context module (Phase 2.3)
4. Seed database from seeding.json (Phase 2.4)
5. Verify questions load correctly from database

DAY 2: Core Functionality
6. Create QuizLive module with basic mount (Phase 3.1-3.3)
7. Implement event handlers (Phase 3.4)
8. Add validation logic (Phase 3.5)
9. Set up routing (Phase 6)

DAY 3: Quiz UI
10. Build quiz view template (Phase 4.1-4.2)
11. Style with DaisyUI components + Tailwind CSS (Phase 4.3-4.4)
12. Test user interaction flow

DAY 4: Results & Testing
13. Build results view template (Phase 5)
14. Implement "Take Another Quiz" flow
15. Write LiveView tests (Phase 8.2)
16. Write context/schema tests (Phase 8.1)

DAY 5: Polish
17. UI/UX refinements (Phase 10.1)
18. Privacy verification (Phase 9)
19. Documentation (Phase 10.3)
20. Final testing and precommit checks (Phase 10.2)

================================================================================
KEY TECHNICAL DECISIONS
================================================================================

1. USE ECTO: For question database ONLY (read-only after seeding)
2. NO USER DATA TABLES: Database contains ONLY questions
3. NO LIVECOMPONENTS: Keep it simple with single LiveView
4. NO SCORING: Only show correct answers and explanations
5. STREAMS: NOT needed (small fixed collection of 10 questions)
6. FORMS: Custom implementation (not Ecto-backed for user input)
7. STATE: User responses only in socket assigns, cleared on disconnect
8. NAVIGATION: Single route, mode switching via assigns
9. DATABASE CHOICE: SQLite for simplicity OR PostgreSQL for production-like setup
10. SEEDING: One-time population from seeding.json via seeds.exs

================================================================================
CRITICAL REMINDERS FROM ARCHITECTURE DOC
================================================================================

- Use <Layouts.app flash={@flash}> wrapper
- Use <.icon name="hero-..."> for icons
- Use Tailwind v4 syntax in app.css
- NO @apply in CSS
- Use list syntax for conditional classes: class={["base", @flag && "extra"]}
- Use <%= for %> for block constructs in templates
- Use {...} for value interpolation in tag bodies and all attributes
- Use <.link navigate={...}> for navigation (not live_redirect)
- NO phx-update="append" (deprecated)
- Add unique IDs to key elements for testing
- HEEx comments: <%!-- comment --%>
- No else if - use cond instead

================================================================================
FILE STRUCTURE OVERVIEW
================================================================================

lib/
  ai_quizzer/
    application.ex
    repo.ex (Ecto repository)
    quiz.ex (context module - public API)
    quiz/
      question.ex (Ecto schema)
  
  ai_quizzer_web/
    components/
      core_components.ex (use existing)
      layouts.ex (use existing)
    live/
      quiz_live.ex (main LiveView)
      quiz_live.html.heex (template)
    router.ex (add live route)
    endpoint.ex (default)

priv/
  repo/
    migrations/
      TIMESTAMP_create_questions.exs
    seeds.exs (populate questions from seeding.json)

test/
  ai_quizzer/
    quiz_test.exs (context tests)
    quiz/
      question_test.exs (schema tests if needed)
  ai_quizzer_web/
    live/
      quiz_live_test.exs

assets/
  css/
    app.css (Tailwind v4 imports)
  js/
    app.js (default, minimal JS needed)

config/
  dev.exs (database config)
  test.exs (test database config)
  runtime.exs (production database config)

seeding.json (source data for questions)

================================================================================
VALIDATION CHECKLIST (BEFORE COMPLETION)
================================================================================

[ ] 10 random questions displayed per session
[ ] Each question requires option selection (radio buttons)
[ ] Each question requires text justification (textarea)
[ ] Submit button disabled until ALL 10 questions complete
[ ] Submit button enabled when all criteria met
[ ] Submission shows results view
[ ] Results show ONLY correct answer and motivation
[ ] NO score/grade/pass-fail displayed
[ ] NO user data persisted anywhere
[ ] NO database calls
[ ] "Take Another Quiz" works and gets new random questions
[ ] Mobile responsive
[ ] Accessible (keyboard navigation)
[ ] All tests passing
[ ] mix precommit passes
[ ] README updated
[ ] Privacy notice visible in UI

================================================================================
END OF IMPLEMENTATION PLAN
================================================================================
